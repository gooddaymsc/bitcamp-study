10일차

===========================================
메모리의 시작점에서 떨어져있는 위치 '오프셋(offset)'

절대적 위치 앱솔루트가 아닌

===========================================

    int[] arr1 = new int[5];
    
    // 배열 선언문 분석:
    // arr1
    //   - 배열 메모리의 주소를 담는 변수이다.
    //   - 이렇게 메모리의 주소를 보관하는 변수를 '레퍼런스'라 부른다.
    //
    // new int[5]
    //   - new 명령은 사용할 메모리를 확보하는 명령이다.
    //   - 즉 연속된 5 개의 int 타입 메모리를 준비하라는 명령이다.
    //   - 사용할 메모리를 확보한 후 그 메모리의 찾아 갈 수 있도록 시작 주소를 리턴한다.
    //   - 이렇게 값을 저장하기 위해 확보된 메모리를 "인스턴스"라 부른다.
    //
    // new 명령은 메모리를 확보하는 명령이다.
    // - 리턴 값은 확보된 메모리의 시작 주소이다.

============가비지 정리=======================

가비지 : 주소를 잃어버려 사용할 수 없는 메모리

//## 가비지(garbage)
//- 주소를 잃어 버려 사용할 수 없는 메모리
//- 특정 조건이 되면 가비지 수집기(garbage collector)에 의해 메모리 해제된다.
//  메모리 해제? 다른 용도로 사용할 수 있도록 표시한다는 의미다.
//  
//## 가비지 수집 조건 = 가비지 컬렉터가 동작할 때
//- 메모리가 부족할 때
//  - 운영체제로부터 메모리를 추가로 받기 전에 먼저 기존에 사용하던 메모리에서 
//    가비지를 제거한다.
//- CPU가 한가할 때
//  - 24시간 365일 내내 실행하는 서버 프로그램인 경우, 실행 중간에 CPU가 한가할 때 
//    가비지를 제거한다.
//- 주의!
//  - 프로그램(JVM)을 종료하면 JVM 사용한 메모리를 운영체제가 모두 회수한다.
//  
//## 가비지를 강제로 지우도록 명령하는 방법?
//- 자바는 없다!
//- C 언어 => free(메모리주소);
//- C++ 언어 => delete 객체주소;
//- 요즘 언어의 트랜드는 사용하지 않는 메모리를 개발자가 직접 해제하는 것이 아니라 
//  VM이 해제하는 것이다.
//  예) JavaScript, C#, Python, PHP, Go, Java 등
//- 요즘 언어의 트랜드는 VM으로 실행하는 것이다.
//  왜? 직접 기계어로 전환되면 메모리를 관리를 자동으로 수행할 수 없다.
//  
//## 가비지 컬렉터를 강제로 실행하는 방법?
//- 없다!
//- 단 원래 계획보다 가능한 빨리 실행하라고 독촉하는 방법은 있다.
//  System.gc() 메서드 호출
//- 그런데 바로 실행할 지 나중에 실행할 지 그 시점을 보장하지는 않는다. 

============================================

int[] arr3 = new int[Integer.MAX_VALUE - 2]; // OK!

.MAX_VALUE

====================heap====================

    int[] arr3 = new int[2147483645]; // 실행 오류 => VM의 배열 크기 제한을 초과
    // Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit

    //    int[] arr3 = new int[2147483645]; // OK!
    //int[] arr3 = new int[Integer.MAX_VALUE - 2]; // OK!

    // 실행 오류 발생!
    // => Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
    // => JVM이 OS로부터 사용 허가를 받은 메모리 크기를 벗어났기 때문에 발생한 것이다.

    // 해결책?
    // => JVM을 실행할 때 최대 힙(heap) 메모리의 크기를 늘리면 된다.
    // => JVM 실행 옵션에 다음을 추가하라!
    //        -Xmx메모리크기
    //    예) $ java -Xmx20000m ...

Run configurations - Arguments - VM arguments: -Xmx12000m


=====================================================

// 2) 배열 선언 + 초기화 명령 II
    int[] arr3 = {100, 90, 80, 70, 60}; // new int[] 생략 가능

실무에서..

====명시적 형변환================================

    float f = 3.14f;
    int i = (int)f; 

float f 가 int로 바뀌는게 아니다.....

=============================================

static type binding vs dynamic type binding

자바
변수의 타입이 한번 정해지면 변경되지 않는다.

자바스크립트
변수에 값을 저장하는 순간 데이터 타입이 결정된다. 변경된다.

==============================================

암시적 형변환 (자동으로 된다~~~)

// 정리!
// - 연산은 항상 같은 타입끼리만 가능하다.
// - 다른 타입끼리 연산을 할 때는 둘 중 한개의 타입을 다른 타입을 
//   바꿔야 한다.
// - 타입을 바꾸는 것을 내부적인 규칙에 따라 자동으로 처리한다고 해서
//   "암시적 형변환(implicit type conversion)"이라 부른다.
// - 암시적 형변환 규칙
//   다음과 같이 오른쪽 타입의 값으로 자동 변환시킨다.
//   byte,short,char => int => long => float => double
//
// - 정수와 부동소수점에 대해서만 암시적 형변환이 일어난다.
//   그 외 다른 타입은 불가능하다!


byte
short  ->    int  ->     long   ->    float   ->     double
char

==============Exam0220 ~ 0221======정리할것===============

    // 소수점 뒤에 붙은 극소수의 값을 무시하면 된다.
    // => JVM이 자동으로 처리하지 않는다.
    // => 다음과 같이 개발자가 직접 처리해야 한다.
    double EPSILON = 0.00001;
    System.out.println(Math.abs((d1 + d2) - (x + y)) < EPSILON);

Math.abs( ) <= Float.POSITIVE_INFINITY
 -> 절대값       <= : 이게 뭘까.

=============ex05  Exam0352 =====================


==============진수 표현법 정리 ==========================
0x... 16진수
Ob... 8진수?

=============조건? 표현식 : 표현식 ==============

=========연산자 우선순위===================

11일차

===========================================
1. 비트 이동 연산자 : >>, >>>, <<

    // << 비트 이동 연산자 사용법
    // - 왼쪽으로 비트를 이동시킨다.
    // - 오른 쪽 빈자리는 0으로 채운다.
    // - 왼쪽 경계를 넘어간 비트는 자른다.

ex)
    int i = 1;
    //      [00000000000000000000000000000001] = 1

    System.out.println(i << 1);
    //     0[0000000000000000000000000000001 ]
    //      [00000000000000000000000000000010] = 2


    // 왼쪽 이동
    // - 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
    // - 값을 배수로 증가시킬 때 곱하기 연산을 하는 것 보다
    //   왼쪽 비트 이동 연산을 하는 것이 빠르기 때문에
    //   실무에서는 이 비트 이동 연산을 자주 사용한다.
    // - 비트 이동 => '2**이동비트'를 곱한 것과 같은 결과를 만든다.
    // - 2^n 으로 이해하자

============================================
2. 비트 이동 연산자 : >>, >>>, <<

    // >> 비트 이동 연산자 사용법
    // - 왼쪽 쪽 빈자리를 원래 숫자와 같은 부호 값으로 채운다.
    // - 양수라면 0, 음수라면 1을 채운다.
    // - 오른쪽 경계를 넘어간 비트는 자른다.

    System.out.println(i); //                   => 105

    System.out.println(i >> 1);
    // [ 0000000000000000000000000110100]1
    // [00000000000000000000000000110100]       => 52

    // 오른쪽 이동
    // - 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
    // - 예) n에 대해 x비트를 오른쪽으로 이동 = n / 2**x
    // - 소수점이 있는 경우 그 수 보다 작은 바로 밑 정수 값이 된다.
    // - 나누기 연산을 수행하는 것 보다 계산 속도가 빠르다.
    //    실무에서는 나눗셈 연산이 비용(시간과 CPU 사용량)이 많이 들기 때문에
    //    소수점 이하까지 정확하게 계산할 게 아니라면
    //    오른쪽 비트 이동 연산자를 사용하여 주로 처리한다.
    //

================exam0440========To do....=====중!!!!! 요!!!!!!======

System.out.println(Integer.toHexString(a));
16진수 문자로 출력

    b = i >> 16 & 0xff;
    //  [00100111_10100001_00110000_11111111] => 27a130ff
    //  [00000000_00000000_00100111_10100001]_00110000_11111111
    //   00000000_00000000_00100111_10100001  => 0x000027a1
    // & 00000000_00000000_00000000_11111111  => 0x000000ff
    // --------------------------------------
    //   00000000_00000000_00000000_10100001

알아보기...

0431 >>>음수를 이동인데 0으로 채운다? 그런뜻인가?

======0460★  0470=====중!!!!! 요!!!!!!=================

비트연산자 응용
    // 특정 비트의 값을 설정할 때
    // 0x01, 0x02, 0x04, 0x08 처럼 직접 숫자를 사용하면
    // 코드를 읽고 이해하기가 쉽지 않다.
    // 해결책?
    // - 각각의 값을 의미있는 이름을 가진 변수에 저장한 후 사용하라.
    // - 또한 조회용으로 사용할 변수이므로 상수로 선언하라.
    //

--------------
   // 정수 값에서 특정 비트의 값만 검사하는 방법
    // 예) 10101010 (C, Java, Python, HTML)
    //
    // CPP 언어를 할 줄 아는지 검사하기
    //     10101010
    //   & 01000000 (조사하려는 값과 AND 한다. 01000000)
    //   ----------------------
    //     00000000
    //
    // AND 결과 값을 검사 값과 같은지 비교하면 된다.
    //     00000000 (결과값)
    //     01000000 (CPP 여부를 조사하는 값)
    // => 결과 값과 조사한 값이 같지 않으면 해당 비트가 0이라는 의미다.


==========ex06 0160

디버그 모드로 실행하며 확인하는 것.
Toggle breakpoint....? - 버그표시 실행 -> step over(F6)

resume(F8) -> 아웃까지 실행(걸리는거 까지 끝까지 감)


===============for와 배열============
    String[] names = {"홍길동", "임꺽정", "유관순", "윤봉길", "안중근"};    
for (String name : names)
      System.out.println(name);

==

    String[] names = {"홍길동", "임꺽정", "유관순", "윤봉길", "안중근"};

    for (int i = 0; i < names.length; i++)
      System.out.println(names[i]);

================ 프로젝트 ==========================


